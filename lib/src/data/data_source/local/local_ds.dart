import 'dart:convert';

import 'package:codegen/codegen.dart' show BaseModel;
import 'package:codegen/model/base_model/base_model.dart' show BaseModel;
import 'package:newsapp/src/data/enums/pref_keys.dart';
import 'package:shared_preferences/shared_preferences.dart';

/// Interface for cache managers to ensure consistent data operations.

abstract class ICacheRepository {
  Future<void> getInstance();

  Future<void> setString(PrefKeys key, String value);
  String? getString(PrefKeys key);

  Future<void> setBool(PrefKeys key, bool value);
  bool? getBool(PrefKeys key);

  Future<void> setInt(PrefKeys key, int value);
  int? getInt(PrefKeys key);

  Future<void> setDouble(PrefKeys key, double value);
  double? getDouble(PrefKeys key);

  Future<void> setStringList(PrefKeys key, List<String> value);
  List<String>? getStringList(PrefKeys key);

  Future<void> remove(PrefKeys key);
  Future<void> clear();
}

/// A singleton class to manage key-value data storage using [SharedPreferences].
///
/// Provides helper methods to store and retrieve data types like String,
/// bool, int, double, and List<String>.
class CacheRepository implements ICacheRepository {
  /// Constructor that initializes [SharedPreferences] manually.
  CacheRepository(this._prefs);

  /// Private named constructor used to initialize the singleton instance.
  CacheRepository._init() {
    getInstance();
  }
  static CacheRepository? _instance;

  /// Returns the singleton instance of [CacheRepository].
  static CacheRepository get instance {
    return _instance ??= CacheRepository._init();
  }

  /// The instance of [SharedPreferences] used for storage.
  SharedPreferences? _prefs;

  /// Initializes the [SharedPreferences] instance asynchronously.
  @override
  Future<void> getInstance() async {
    if (_prefs != null) return;
    _prefs = await SharedPreferences.getInstance();
  }

  /// Encodes a unique cache key by combining the runtime type and an identifier.
  ///
  /// This helps distinguish different types of objects that might share the same [id].
  ///
  /// Example:
  /// ```dart
  /// idCoder("123", UserModel); // returns "UserModel/123"
  /// ```
  ///
  /// [id] - A unique identifier for the object.
  /// [runtimeType] - The runtime type of the object being cached.
  ///
  /// Returns a string key to be used in the shared preferences.
  String idCoder(String id, Type runtimeType) => '$runtimeType/$id';

  /// Caches a generic model object in local storage by encoding it to a JSON string.
  ///
  /// This method serializes the given [model] using `jsonEncode` and stores it
  /// under a unique key generated by [idCoder].
  ///
  /// [id] - A unique identifier for the model object.
  /// [model] - The model object to be cached. Must extend [BaseModel] and implement `toJson`.
  ///
  /// Returns a [Future] that resolves to `true` if the operation was successful.
  Future<bool> cacheGenericModel<T>(String id, BaseModel<T> model) async {
    final stringModel = jsonEncode(model);
    final codedId = idCoder(id, model.runtimeType);
    return _prefs!.setString(codedId, stringModel);
  }

  /// Retrieves and deserializes a generic model object from local storage.
  ///
  /// This method fetches a cached JSON string using a unique key generated by [idCoder],
  /// then deserializes it into a model object using the provided [model]'s `fromJson` method.
  ///
  /// [id] - The unique identifier used when caching the model.
  /// [model] - A model instance used as a factory for deserialization.
  ///           Must extend [BaseModel] and implement `fromJson`.
  ///
  /// Returns a [Future] that resolves to the deserialized model object of type [T].
  Future<T> getGenericModel<T>(String id, BaseModel<T> model) async {
    final codedId = idCoder(id, T.runtimeType);
    final stringModel = _prefs!.getString(codedId);

    final stringJson = jsonDecode(stringModel ?? '');
    return model.fromJson(stringJson as Map<String, dynamic>);
  }

  /// Removes a cached generic model object from local storage.
  ///
  /// This method deletes a stored model by generating a unique key using [idCoder]
  /// based on the provided [id] and the runtime type of [T].
  ///
  /// [id] - The unique identifier used when caching the model.
  /// [model] - The model object used to infer the type for key generation.
  ///
  /// Returns a [Future] that resolves to `true` if the value was successfully removed.
  Future<bool> removeGenericModel<T>(String id, T model) async {
    final codedId = idCoder(id, T.runtimeType);
    return _prefs!.remove(codedId);
  }

  /// Stores a string value for the given [key].
  @override
  Future<bool> setString(PrefKeys key, String value) async =>
      _prefs!.setString(key.rawValue, value);

  /// Retrieves a string value associated with the given [key].
  @override
  String? getString(PrefKeys key) => _prefs!.getString(key.rawValue);

  /// Stores a boolean value for the given [key].
  @override
  Future<bool> setBool(PrefKeys key, bool value) async => _prefs!.setBool(key.rawValue, value);

  /// Retrieves a boolean value associated with the given [key].
  @override
  bool? getBool(PrefKeys key) => _prefs!.getBool(key.rawValue);

  /// Stores an integer value for the given [key].
  @override
  Future<bool> setInt(PrefKeys key, int value) async => _prefs!.setInt(key.rawValue, value);

  /// Retrieves an integer value associated with the given [key].
  @override
  int? getInt(PrefKeys key) => _prefs!.getInt(key.rawValue);

  /// Stores a double value for the given [key].
  @override
  Future<bool> setDouble(PrefKeys key, double value) async =>
      _prefs!.setDouble(key.rawValue, value);

  /// Retrieves a double value associated with the given [key].
  @override
  double? getDouble(PrefKeys key) => _prefs!.getDouble(key.rawValue);

  /// Stores a list of strings for the given [key].
  @override
  Future<bool> setStringList(PrefKeys key, List<String> value) async =>
      _prefs!.setStringList(key.rawValue, value);

  /// Retrieves a list of strings associated with the given [key].
  @override
  List<String>? getStringList(PrefKeys key) => _prefs!.getStringList(key.rawValue);

  /// Removes the value associated with the given [key].
  @override
  Future<void> remove(PrefKeys key) async => _prefs!.remove(key.rawValue);

  /// Clears all stored key-value pairs.
  @override
  Future<void> clear() async => _prefs!.clear();
}
